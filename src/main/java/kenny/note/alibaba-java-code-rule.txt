【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾


【强制】POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误


【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁
性，并加上有效的 javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是
与接口方法相关，并且是整个应用的基础常量。


【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部
的实现类用 Impl 的后缀与接口区别。


【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。


【参考】插入的方法用 save（推荐）或 insert 做前缀;
删除的方法用 remove（推荐）或 delete 做前缀。


【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；
系统配置相关的常量放在类：ConfigConsts 下。


【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包
内共享常量、类内共享常量。


【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。


【强制】所有的覆写方法，必须加@Override 注解。


【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。
接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。


【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。


【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。


【强制】POJO 类必须写 toString 方法。使用工具类 source> generate toString 时，如果继
承了另一个 POJO 类，注意在前面加一下 super.toString。


【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，
否则会有抛 IndexOutOfBoundsException 的风险。
String str = "a,b,c,,";
String[] ary = str.split(",");
System.out.println(ary.length); //预期大于 3，结果是 3


【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。


【推荐】慎用 Object 的 clone 方法来拷贝对象。
对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的
拷贝。


【强制】Map/Set 的 key 为自定义对象时，必须重写 hashCode 和 equals。
正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作
为 key 来使用。


【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，
它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。
说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList
体现的是适配器模式，只是转换接口，后台的数据仍是数组。
    String[] str = new String[] { "a", "b" };
    List list = Arrays.asList(str);
第一种情况：list.add("c"); 运行时异常。
第二种情况：str[0]= "gujin"; 那么 list.get(0)也会随之修改。


【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法。
说明：苹果装箱后返回一个<? extends Fruits>对象，此对象就不能往里加任何水果，包括苹
果。


【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。
正例：
Iterator<String> it = a.iterator();
while(it.hasNext()){
String temp = it.next();
if(删除元素的条件){
it.remove();
}
}


【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort，
Collections.sort 会报 IllegalArgumentException 异常。
说明：
 1） 自反性：x，y 的比较结果和 y，x 的比较结果相反。
 2） 传递性：x>y,y>z,则 x>z。
 3） 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。
反例：下例中没有处理相等的情况，实际使用中可能会出现异常：
new Comparator<Student>() {
@Override
public int compare(Student o1, Student o2) {
return o1.getId() > o2.getId() ? 1 : -1;
}
}


【推荐】集合初始化时，尽量指定集合初始值大小。
ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。


【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。
说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key
所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更
高。如果是 JDK8，使用 Map.foreach 方法。
正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是
一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。


【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：
集合类             Key          Value         Super        说明
Hashtable         不允许为 null 不允许为 null  Dictionary    线程安全
ConcurrentHashMap 不允许为 null 不允许为 null  AbstractMap   线程局部安全
TreeMap           不允许为 null 允许为 null    AbstractMap   线程不安全
HashMap           允许为 null   允许为 null    AbstractMap   线程不安全


【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不
稳定性(unorder)带来的负面影响。
说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则
依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是
order/sort。


【参考】利用 Set 元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用 List 的
contains 方法进行遍历去重操作。


【推荐】推荐尽量少用 else， if-else 的方式可以改写成：
if(condition){
…
return obj;
}
// 接着写 else 的业务逻辑代码;
说明：如果使用要 if-else if-else 方式表达逻辑，【强制】请勿超过 3 层，超过请使用状态设计模式。


【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，
如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。


【强制】类、类属性、类方法的注释必须使用 javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。
说明：在 IDE 编辑窗口中，javadoc 方式会提示相关注释，生成 javadoc 可以正确输出相应注
释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高
阅读效率.


【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、
异常说明外，还必须指出该方法做什么事情，实现什么功能。


【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使 用/* */注释，注意与代码对齐。


【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，
经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。
 1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）
   表示需要实现，但目前还未实现的功能。这实际上是一个 javadoc 的标签，目前的
javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 javadoc
标签）。
2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）
   在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。


【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值范围 0≤x<1（能够取 到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取
整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。


【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime。在 JDK8 中，针对统计时
间等场景，推荐使用 Instant 类。


【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：
IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保
证程序健壮性。
正例：if(obj != null) {...}
反例：try { obj.method() } catch(NullPointerException e){…}


【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
正例：（条件）
if (logger.isDebugEnabled()) {
logger.debug("Processing trade with id: " + id + " symbol: " + symbol);
}
正例：（占位符）
logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);


【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。
说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错
非常有价值。



*************************************************************************************
并发处理
【强制】获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。
说明：资源驱动类、工具类、单例工厂类都需要注意。


【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资
源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者
“过度切换”的问题。


【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。
正例：注意线程安全，使用 DateUtils。亦推荐如下处理：
private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
@Override
protected DateFormat initialValue() {
return new SimpleDateFormat("yyyy-MM-dd");
}
};
说明：如果是 JDK8 的应用，可以使用 instant 代替 Date，Localdatetime 代替 Calendar，
Datetimeformatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong
immutable thread-safe。


【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。


【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样
的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors 各个方法的弊端：
1）newFixedThreadPool 和 newSingleThreadExecutor:
  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。
2）newCachedThreadPool 和 newScheduledThreadPool:
  主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM


【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed
导致的性能下降。
说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。
正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个线
程一个实例。


【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患
(可参考 The "Double-Checked Locking is Broken" Declaration),推荐问题解决方
案中较为简单一种（适用于 jdk5 及以上版本），将目标属性声明为 volatile 型（比如反例
中修改 helper 的属性声明为 private volatile Helper helper = null;）；


【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，
但是如果多写，同样无法解决线程安全问题。如果想取回 count++数据，使用如下类实现：
AtomicInteger count = new AtomicInteger(); count.addAndGet(1); count++操作如果是
JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。


【参考】注意 HashMap 的扩容死链，导致 CPU 飙升的问题。


【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。
这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态
变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这
个线程内定义的)都可以操控这个变量。


*************************************************************************************

【强制】不得使用外键与级联，一切外键概念必须在应用层解决。


【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。